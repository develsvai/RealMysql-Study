## 4장 아키텍쳐 

mysql 서버는 사람의 머리역활을 담당하는 MySql 엔진과 손발을 담당하는 스토리지 엔진으로 구분할수 있다. 
그리고 손과 발의 역활을 담당하는 스토리지 엔진은 핸들러 api를 만족하면 누구든지 스토리지 엔진을 구현해서 MySql 서버에 추가해서 사용할수 있다. 
이번장에서는 MySql 엔진과 MySql 서버에서 기본으로 제공되는 InnoDB 스토리지 엔진, 그리고 MySql 스토리지 엔진을 구분해서 살펴보겠다. 

## 4.1.1 MySql 엔진 아키텍쳐 

<img width="392" alt="스크린샷 2024-02-13 오전 1 26 33" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/74d31211-0506-43e5-87c8-d02423bdfe4a">

#### 1.MySql은 다른 RDBMS와 같이 대부분의 프로그래밍 언어로 부터의 접근 방법을 모두 지원한다. 
#### 2.MySql은 C API부터 JDBC,ODBC,.NET표준 드라이버 를 제공하여 이를 활용해 프로그래밍 언어를 통해 접근 가능 하다. 

### 4.1.1.1 MySql 엔진 
MySql 엔진은 클라이언트 로 부터의 접속 및 쿼리 요청 을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화 된 실행을 위한 옵티마이저가 중심을 이룬다. 
MySql 은 표준 SQL문법 을 따르기에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행 할수 있다. 


### 4.1.1.2 스토리지 엔진 
MySql 엔진 은 요청된 SQL 문장을 분석하거나 최적화 하는 등 DBMS 의 두뇌에 해당 하는 처리를 수행한다. 
Storage 엔진은 데이터를 드라이브에 저장 또는 디스크 스토리지로 부터 데이터를 읽어오는 등의 역활을 수행한다. 

MySql 서버에서 MySql엔진은 하나이지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다 .

myslq > CREATE TABLE test_table (fd1 INT, fd2, INT) ENGINE=INNOBD;
위와 같이 지정하면 사용할 스토리지 엔진을 지정할수 있다. 

### 4.1.1.3 핸들러 API 
MySql 엔진의 쿼리 실행기 에서 데이터를 쓰거나 읽어야 할때는 각 스토리지 엔진에 쓰기 또는 읽기 를 요청하는데 이러한 요청을
핸들러(Handler) 요청이라 함.

여기서 사용되는 API를 핸들러 API 라고 함. 
InnoDB 스토리지 엔진 또한 이핸들로 API를 이용해 MySql 엔진과 데이토를 주고 받는다 .

핸들로 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지는 

mysql > SHOW GLOBAL STATUS LIKE 'Handler%';

<img width="247" alt="스크린샷 2024-02-13 오전 2 11 05" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/8b191723-9be1-448a-9ba6-de5cae7f79f5">

위의 명령어로 확인 할 수 있다. 


## 4.1.2 MySql 스레딩 구조 

MySql 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며 

포그라운드(foreground) , 백그라운드(background) 나눌수 있다.

실행중인 스레드 목록은 

<img width="571" alt="스크린샷 2024-02-13 오전 2 16 35" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/d9e1a1e3-24d2-40bb-a475-6260811f8fbd">

위와같이 확인 할 수 있다.

### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 최소한 MySql 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리함. 

클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레트 캐시로 되돌아감.

단 스래드 캐시에 이미 일정 개수 이상의 스레드 가 존재하면 캐시에 넣지 않고 , 스레드를 종료 시키고 일정 개수의 스레드 수 를 유지함.(이는 시스템 변수로 설정가능)

포그라운드 스레드는 데이터를 MySql의 데이터 캐시로 부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로 부터 데이터를 읽어와서 작업을 처리한다. 

MyISAM(스토리지 엔진 중 하나) 데이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만 InnoDB 테이블은 데이터 버터나 캐시까지만 포그라운드 스레드가 처리하고, 버퍼로부터 디스크 까지 기록하는 작업은 백그라운드 스레드가 처리한다. 

### 4.1.2.2 백그라운드 스레드 

InnoBD의 백그라운드 처리 목록

1.인서트 버퍼를 병합하는 스레드 
2.로그를 디스크로 기록하는 스레드 (중요)
3.innoDB 버퍼 폴의 데이터를 디스크에 기록하는 스레드 (중요)
4.데이터를 버퍼로 읽어 오는 스레드 
4.잠금이나 데드락을 모니터링 하는 스레드 

InnoDB 에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리 되기에 많이 할당하지 않아두됨 
쓰기 스레드는 많은 일을 처리하기 때문에 디스크를 최적으로 사용할 수 있는 만큼 충분히 설정하는 것이 좋음

유저의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링) 되어 처리될수 있지만 데이터의 읽기 작업은 절대 지연불가!

일반적인 상용 DBMS는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 가능이 탑제 되어있고 InnoDB 또한 마찬가지 
단 MyISAM은 쓰기 버퍼링 을 지원 하지 않기에 불가 !


## 4.1.3 메모리 할당 및 사용구조 

![img](https://github.com/develsvai/RealMysql-Study/assets/125961256/688b5e4f-261b-4b35-8555-31eb608825f0)

MySql 에서 사용되는 메모릴 공간은 크게 글로벌 메모리 영역, 로컬 메모리 영역으로 구분 

글로벌 메모리 영역의 모든 메모리 공간은 MySql 서버가 시작되면서 운영체제로부터 할당 됨

os의 종류에 따라 요청된 메모리 공간을 100% 할당도 해줄수 있고 , 예약 해두고 필요할때 줄수 도 있음

### 4.1.3.1 글로벌 메모리 영역 

일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 단 필요에 따라 2개 이상의 메모리 공간을 할당 받을 수도 있다. 단 클라이언트 스레드 수와는 무관하며 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 공유된다. 

영역

1.테이블 케시 
2.innoDB 버퍼 풀
3.innoDB 어댑티브 해시 인덱스 
4.innoDB 로그 버퍼 


4.1.3.2
세션 메모리 영역라고도 표현되며, Mysql 서버상에 존재하는 클라이너트 스레드 가 뭐리를 처리하는데 사용되는 메모리 영역이다. 

MySql 서버에서는 클라이언트 커넥션 으로 부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역 이라고도 함.

클라이언트 와 MySql 서버와의 커넥션을 세션이라고 함

로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유 되어 사용되지 않는다는 특징이 있다. 

로컬 메모리가 부족하면 MySql 서버가 메모리 부족으로 으로 인하여 멈춰 버릴 수도 있음으로 적절한 공간을 설정 해야 한다. 

특징 
각 쿼리 의 용도별로 필요할 때만 공간이 할당되고 필요하지 않는 경우 에는 공간을 할당 하지 않을 수 있다.(정렬 버퍼나 조인버퍼) 

단 커넥션 버퍼나 결과버퍼 메모리 같은 경우에는 커넥션이 열려 동안에는 계속 해서 남아있다. 

영역 
1. 정렬 버퍼
2. 조인버퍼
3. 바이너리 로그 캐시
4. 네트워크 버퍼


## 4.1.4 플러그인 스토리지 엔진 모델 

플러그인 모델은 Mysql 의 톡특한 점중 하나이다. 

플러그 인을 통해 사용할 수 있는 것이 스토리지 엔진 뿐만은 아님(전문 검색 엔진을 위한 검색어 파서도 플러그인으로 구현 )

MySql 은 기본적으로 많은 스토리지 엔진을 가지고 있다. 

MySql 서버와 스토리지 엔진의 처리영역 
<img width="524" alt="스크린샷 2024-02-15 오전 2 44 43" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/c575ae52-6e66-4760-9346-6b4d5e641266">

각 처리영역에서 '데이터 읽기/쓰기' 작업의 단위는 1레코드 이다. 

MySql 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는 것을 사용함

Sql 엔진 이 각 스토리지 엔진 에게 데이터를 읽어 오거나 저장하도록 명령 하려면 반드시 핸들러를 통해야함.


MySql 서버의 상태변수('Handler_'로 시작 하는 변수 ) -> Sql 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수 

## 4.1.5 컴포넌트 

Mysql 8.0 부터 도입된 플러그인 아키텍쳐를 대채하기 위해 나온 개념 , 플러그인 의 단점을 보안 

플러그인의 단점 
1. 플러그인은 오직 MySql 서버와만 인터페이스 할수 있고 플러그인 들끼리는 불가함
2. 플러그인은 MySql 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음( 캡슐화 블가)
3. 플러그인은 상호의존 관계 를 설정하수 없어서 초기화 가 어려움


## 4.1.6 쿼리 실행 구조 

<img width="359" alt="스크린샷 2024-02-15 오전 2 54 42" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/ef3a420e-6044-4a8f-99b5-4adf236085c0">



### 4.1.6.1 쿼리 파서 

쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰(SQL 이 인식 할수 있는 최소 단위의 어휘나 기호)로 분리해 트리 형태의 구조로 만들어내는 작업을 의미한다.(파서? 하는 주체 아닌가..?) 이과정에서 문법오류를 잡아냄

### 4.1.6.2 전처리기 

파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 각 토큰 테이블 이름이나 컬럼이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체 의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 이 단계 에서 수행한다. 살제 존재하지 않거나 권한상 사용할수 없는 개채의 토큰은 이단계 에서 걸러진다. 


### 4.1.6.3 옵티마이저 

사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역활을 담당,
DBMS의 두뇌에 해당, 옵티마이저의 역활은 중요하고 영향 범위또한 넓다 .

### 4.1.6.4 실행 엔진 

옵티마이저 -> 경영진, 실행엔진 -> 중간관리자(과,부장급?), 핸들러 -> 실무자

1. 실행엔진이 핸들러 에게 임시 테이블을 만들라고 요청
2. 다시 실행엔진 은 WHERE 절에 일치하는 레코드를 읽어 오라고 핸들로에게 요청
3. 읽어온 레코드들을 1본에서 준비한 임시테이블로 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러 에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

### 4.1.6.5  핸들러(스토리지 엔진)

핸들러는 SQL 서버 의 가장 밑단에서 SQL실행 엔진 의 요청 에 따라 데이토를 디스트로 저장하고 디스크 로 부터 읽어 오는 역활을 담다, 핸들러는 결국 스토리지 엔진을 의미 한다.

## 4.1.7 복제 
16장에서 계속 



## 4.1.8 쿼리 캐시 
쿼리 캐시는 바른 응답을 필요로 하는 윕 기반의 응용 프로그램 에서 매우 중요한 역활을 담당한다. 쿼리 캐시는 SQL의 실행 결과를 메모리 에 캐시 하고 동일 쿼리가 실행되면 테이블에서 읽지 않고 즉시 결과 를 반환한다. 

하지만 캐시에 저장된 결과중 변경된 테이블과 관련된 것들은 전부 삭제 되어야 하기에 심각한 동시 처리 성능 저하를 유발, MySql8.0 부터는 완전히 제거되었다.

## 4.1.9 스레드풀 

스레드 스케쥴러 역활 ..?

## 4.1.10 트랜잭션 지원 메타 데이터 
8.0 부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 Inno DB 의 테이블에 저장,




