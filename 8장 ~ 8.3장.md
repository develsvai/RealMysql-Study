# Chapter 08

Status: Not started

### 디스크 읽기 방식

- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- 디스크 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 하드 디스크 드라이브보다 조금 빠르거나 비슷한 성능을 보일 수 있다.
- 하지만 데이터베이스 서버에서 순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD의 장점은 DBMS용 스토리지에 최적이다.
    - SSD는 디스크 원판을 기계적으로 회전시키지 않고 플래시 메모리를 통해 데이터를 읽고 쓴다.

### 랜덤 I/O와 순차 I/O

- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다.
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
    - 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용한다.
    - 따라서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.
    - 이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 레코드를 읽어올 수 있기 때문인데, 이런 형태는 OLTP 보다는 데이터 웨어하우스나 통계 작업에서 주로 사용된다.

### 인덱스란?

- DBMS의 인덱스는 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.
- 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높인다.
- 인덱스는 프라이머리 키(Primary key)와 보조 키(Secondary key)로 구분한다.
    - 프라이머리 키는 테이블에서 해당 레코드를 식별할 수 있는 기준값이 된다. Null이 허용되지 않으며 중복을 허용하지 않는다.
    - 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류한다.
- 데이터 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
    - 옵티마이저가 유니크 인덱스에 대해 동등 조건(Equal)로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 알 수 있도록 한다.

### B-Tree 인덱스

- B-Tree는 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘이다.
- B-Tree은 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.

### B-Tree 구조 및 특성

![Untitled](Chapter%2008%20fb22492ebf754010a1e73f9a08610fbc/Untitled.png)

- B-Tree는 트리 구조의 최상위에 하나의 루트 노드(Root node)가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.
- 트리 구조의 가장 하위에 있는 노드를 리프 노드(Leaf node)라고 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 브랜치 노드(Branch node)라고 한다.
    - 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
- 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
- InnoDB 테이블에서 레코드는 클러스터링되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
- InnoDB 테이블에서는 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
    - 즉, InnoDB 스토리지 엔진은 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

### B-Tree 인덱스 키 추가

- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 정확한 위치를 검색해야 한다.
- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
- 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.
- 위와 같은 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.
- 인덱스 추가로 인한 INSERT나 UPDATE 쿼리에 어떤 영향이 미칠까
    - 이를 확인하기 위해선 테이블의 컬럼 수, 컬럼의 크기, 인덱스 컬럼의 특성 등을 확인해야 한다.
    - 대략적으로 계산하는 방법 = 테이블에 레코드를 추가하는 작업 비용이 1이라고 가정하면, 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5정도로 예측하는 것이다.
    - 테이블에 인덱스가 하나도 없다면 작업 비용은 1, 인덱스가 3개인 경우에는 5.5(1.5 * 3 + 1) 정도의 비용으로 예측해 볼 수 있다.
    - 비용의 대부분은 메모리와 CPU에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이다.
- MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블은 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
- InnoDB 스토리지 엔진은 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.
    - 하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.

### 인덱스 키 삭제

- B-Tree의 키 값이 삭제하면 해당 키 값이 저장된 리프 노드를 찾아서 삭제 마크만 진행한다.
- 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.
- 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 필요하다.
    - MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수 있다.
- MyISAM이나 MEMORY 스토리지 엔진의 테이블에서는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.

### 인덱스 키 변경

- 인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다.
- B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
    - 결국 인덱스 키 값을 변경하는 작업은 기존 인덱스 키 값을 삭제한 후 새로운 인덱스 키 값을 추가하는 작업으로 처리되고, InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있다.

### 인덱스 키 검색

- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.
- 부등로(<, >) 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.
- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다. 따라서 UPDATE나 DELETE 쿼리가 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.
- INSERT의 경우에는 INSERT Intention Gap Lock을 사용하는데, INSERT 할 때 키가 겹치지 않는다면 대기하지 않고 실행될 수 있도록 하는 락의 종류다.
    - INSERT Intention과 Gap Lock은 베타적이다.

### 인덱스 키 값의 크기

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
- 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이며, 인덱스 또한 페이지 단위로 관리된다.
- 인덱스를 구성하는 키 값의 크기가 커지면 하나의 인덱스 페이지에 저장될 수 있는 자식 노드의 개수가 줄어든다.
    - 따라서 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 의미이다.
    - 또한 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커지는 것이므로 인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다. 결국 메모리의 효율이 떨어지는 결과를 가져온다.

### B-Tree 깊이

- B-Tree 인덱스의 깊이는 중요하지만 직접 제어할 방법은 없다.
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.
- 지금까지의 내용으로 결론은 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다는 것이며, 실제로 아무리 대용량 데이터베이스라도 B-Tree의 깉이가 5단계 이상까지 깊어지는 경우는 흔치 않다고 한다.

### 선택도 (기수성, Cardinality)

- 인덱스에서 선택도 또는 기수성은 거의 같은 의미로 사용되며, 모든 인덱스 값 가운데 유니크한 값의 수를 의미한다.
    - 전체 인덱스 키 값은 100개인데, 그중에서 유니크한 값의 수는 10개라면 기수성은 10이다.
- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
- 선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다.
    - 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러 가지 용도를 고려해 적절히 인덱스를 설계할 필요가 있다.
- MySQL에서는 인덱스의 통계 정보가 관리된다. (유니크한 값의 개수)

### 읽어야 하는 레코드 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
- 인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있는데, 일반적인 DBMS의 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 드는 작업인 것으로 예측한다.
    - 즉, 인덱스를 통해 읽어야 할 레코드의 건수(옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적이다.

### 인덱스 레인지 스캔

![Untitled](Chapter%2008%20fb22492ebf754010a1e73f9a08610fbc/Untitled%201.png)

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
- 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾으면 필요한 레코드의 시작 지점을 찾을 수 있다.
    - 일단 시작해야 할 위치를 찾으면 그때부터 리프 노드의 레코드만 순서대로 읽으면 된다.
    - 리프 노드를 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다.
- 리프 노드를 스캔하고 나면 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다.
    - 커버링 인덱스로 처리하는 경우에는 데이터 파일에 접근할 필요가 없다.
    - 커버링 인덱스는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다.
- 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업이다.

### 인덱스 풀 스캔

![Untitled](Chapter%2008%20fb22492ebf754010a1e73f9a08610fbc/Untitled%202.png)

- 인데스의 처음부터 끝까지 모두 읽는 방식이다.
- 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
- 일반적으로는 인덱스의 크기가 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적이다.
    - 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.
- 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이방식으로 처리되지 않는다.
- 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. (테이블의 레코드들을 읽을 필요가 없을 경우에만)

### 루스 인덱스 스캔

![Untitled](Chapter%2008%20fb22492ebf754010a1e73f9a08610fbc/Untitled%203.png)

- 오라클과 같은 DBMS의 인덱스 스킵 스캔이라고 하는 기능과 작동 방식이 비슷하며, MySQL에서는 루스 인덱스 스캔이라고 한다.
- MySQL 8.0 버전부터는 다른 상용 DBMS에서 지원하는 인덱스 스킵 스캔과 같은 최적화를 지원하기 시작했따.
- 루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 동작하지만 중간에 필요치 않은 인덱스 키 값은 무시(Skip)하고 다음으로 넘어가는 형태로 처리한다.
    - 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다.

### 인덱스 스킵 스캔

- 데이터베이스 서버에서 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다.

```sql
ALTER TABLE employees
	ADD INDEX ix_gender_birthdate (gender, birth_date);

-- 인덱스를 사용하지 못하는 쿼리
SELECT * FROM employees WHERE birth_date >= '1965-02-01';

-- 인덱스를 사용할 수 있는 쿼리
SELECT * FROM employees WHERE gender = 'M' and birth_date >= '1965-02-01';
```

- 위 쿼리에서 두 번째 쿼리는 인덱스를 효율적으로 사용할 수 있지만, 첫 번째 쿼리는 gender 컬럼에 대한 비교 쿼리가 존재하지 않아서 인덱스를 효율적으로 사용할 수 없었다.
- MySQL 8.0 부터는 옵티마이저가 gender 컬럼을 건너뛰어서 birth_date 컬럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.
- MySQL 8.0 이전 버전에서도 인덱스 스캔과 비슷한 최적화를 수행하는 루스 인덱스 스캔이라는 기능이 있었지만 루스 인덱스 스캔은 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용할 수 있었다.
- 하지만 인덱스 스킵 스캔은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 훨씬 넓어졌다.
    
    ![Untitled](Chapter%2008%20fb22492ebf754010a1e73f9a08610fbc/Untitled%204.png)
    
- gender 컬럼은 성별을 구분하는 컬럼으로 ‘M’과 ‘F’ 값만 가지는 ENUM 타입의 컬럼이기 때문에 gender 컬럼에 대해 가능한 값 2개를 구한 다음, 옵티마이저는 내부적으로 아래 2개의 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행하게 된다.

```sql
SELECT * FROM employees WHERE gender = 'M' and birth_date >= '1965-02-01';
SELECT * FROM employees WHERE gender = 'F' and birth_date >= '1965-02-01';
```

- 인덱스 스킵 스캔은 WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 개수가 적어야 한다.
    - 만약 유니크한 값의 개수가 매우 많다면 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해지므로 오히려 더 느려질 수 있기 때문이다.
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야 한다. (커버링 인덱스)

### 다중 컬럼 인덱스

- 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라고 한다.
- 두 개의 컬럼이 인덱스로 걸려있다고 가정하면, 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬돼 있다.
    - 즉, 두 번째 컬럼의 정렬은 첫 번째 컬림이 똑같은 레코드에서만 의미가 있다는 것이다.
- 두 개 이상의 컬럼에서도 마찬가지로, 뒤의 컬럼은 앞의 컬럼에 의존해서 정렬된다.
- 따라서 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 순서는 상당히 중요하므로 신중히 결정하는 것이 좋다.

### B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스는 오름차순이나 내림차순으로 정렬되어 있는데, 오름차순으로 생성되었다고 해서 그 인덱스를 오름차순으로만 읽을 수 있는 것은 아니다.
    - 그 인덱스를 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로도 사용될 수도 있는 것이다.
- 인덱스를 어느 방향을 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.

### 인덱스의 정렬

- MySQL 5.7 버전까지는 컬럼 단위로 정렬 순서를 혼합해서 인덱스를 생성할 수 없었기 때문에 숫자 컬럼의 경우 -1을 곱한 값을 저장하는 우회 방법을 사용하기도 했었다.
- MySQL 8.0 버전부터는 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다.

```sql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

### 인덱스 스캔 방향

- 인덱스는 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.
- 쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.

### 내림차순 인덱스

- 오름차순 인덱스 : 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- 내림차순 인덱스 : 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- 인덱스 정순 스캔 : 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- 인덱스 역순 스캔 : 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
- MySQL 서버의 InnoDB 스토리지 엔진에서 정순 스캔과 역순 스캔은 페이지 블록 간의 양방향 고리를 통해 전진하느냐 후진하느냐의 차이만 있지만, 실제 내부적으로는 InnoDB에서 인덱스 역순 스캔이 인덱스 정슨 스캔에 비해 느릴 수 밖에 없다.
    - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이기 때문
    - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조이기 때문
- InnoDB 페이지 내부에서 레코드들은 실제로 힙처럼 사용되기 때문에 물리적으로 저장이 순서대로 배치되지 않는다.
- 일반적으로 인덱스를 ORDER BY … DESC하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면 내림차순 인덱스를 굳이 고려할 필요는 없다.
    - 하지만 위 형태의 쿼리가 많은 레코드를 조회하면서 빈번하게 실행된다면 내림차순 인덱스가 더 효율적일 수 있으므로 내림차순 인덱스를 고려해보면 좋다.
- 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 된다.

### 비교 조건의 종류와 효율성

- 다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 동등 비교인지 아니면 범위 조건인지에 따라 인덱스 컬럼의 활용 형태가 달리자며, 효율 또한 달라진다.
- 동등 비교와 같이 작업 범위를 결정할 수 있는 조건이 많을 수록 쿼리의 성능을 높이는데 도움이 되고, 작업의 범위를 줄이지 못하고 단순히 조건에 따라 필터링만 하는 조건은 쿼리 성능을 높이지는 못한다.
    - 필터링 조건은 오히려 쿼리 실행을 더 느리게 만들 때가 많다.

### 인덱스의 가용성

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다는 것이다.
    - 즉, 하나의 컬럼으로 검색해도 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가능하다. 다중 컬럼 인덱스에서도 마찬가지다.
- 왼쪽 값 기준 규칙은 GROUP BY 절이나 ORDER BY 절에도 똑같이 적용된다.

### 가용성과 효율성 판단

- B-Tree 인덱스의 특성상 다음 조건에서는 작업 범위 결정 조건으로 사용할 수 없다.
    - NOT-EQUAL로 비교된 경우(”<>”, “NOT IN “, “NOT BETWEEN”, “IS NOT NULL”)
    - LIKE ‘%??’ (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
    - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
        - WHERE SUBSTRING(column, 1, 1) = ‘X’
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
        - WHERE column = deterministic_function()
    - 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우
        - WHERE char_column = 10
    - 문자열 데이터 타입의 콜레이션이 다른 경우
        - WHERE utf8_bin_char_column = euckr_bin_char_column
- 다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장된다. 다음과 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.

```sql
... WHERE column IS NULL ...
```

- 다중 컬럼 인덱스 예시

```sql
INDEX ix_test (column_1, column_2, column_3, .., column_n)
```

- 다중 컬럼 인덱스의 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 컬럼에 대한 조건이 없는 경우
    - column_1 컬럼의 비교 조건이 인덱스 사용 불가 조건 중 하나인 경우
- 다중 컬럼 인덱스의 작업 범위 결정 조건으로 인덱스를 사용하는 경우
    - column_1 ~ column_(i-1) 컬럼까지 동등 비교 형태(”=” 또는 “IN”)로 비교
    - column_i 컬럼에 대해 다음 연산자 중 하나로 비교
        - 동등 비교 (”=” 또는 “IN”)
        - 크다 작다 형태 (”<” 또는 “>”)
        - LIKE로 좌측 일치 패턴 (LIKE ‘윤%’)
