# Chapter 05

Status: Not started

## 트랜잭션과 잠금

- 트랜잭션은 정합성을 보장하기 위한 기능이다.
- 잠금은 동시성을 제어하기 위한 기능이다.
    - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

### MySQL에서의 트랜잭션

- MyISAM이나 MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않는다.
- 트랜잭션은 하나의 논리적인 작업 셋이 모두 성공하거나 모두 실패함을 보장해주는 것이다.
- 트랜잭션은 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
    - 트랜잭션 내에 네트워크 작업이 있는 경우에는 특히 주의해야 한다.

### MySQL 엔진의 잠금

- MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔젠 레벨로 나눌 수 있다.
- MySQL 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다.

### 글로벌 락(Global Lock)

- 글로벌 락은 FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있다.
- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 대기한다.
    - 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체다.
    - 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
- InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다.
- MySQL 8.0 버전부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생겼는데, 이에 백업 락이 도입됐다.
    - 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.

### 테이블 락(Table Lock)

- 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.
- 명시적으로는 “LOCK TABLES table_name [READ | WRITE]” 명령으로 특정 테이블의 락을 획득할 수 있다.
    - 명시적으로 획득한 잠금은 UNLOCK TABLES 명령으로 잠금을 반납(해제)할 수 있다.
- 명시적인 테이블 락도 애플리케이션에서 사용할 일이 거의 없다.
- 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
    - MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다.
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순히 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다.
    - 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 DML 쿼리에서는 무시되고 스키마를 변경하는 DDL의 경우에만 영향을 미친다.

### 네임드 락(Named Lock)

- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 대상 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니라 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.

### 메타데이터 락(Metadata Lock)

- 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
- 명시적으로 획득하거나 해제할 수 잇는 것이 아니고, “RENAME TABLE tab_a TO tab_c” 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

### InnoDB 스토리지 엔진 잠금

- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
    - 레코드 기반 잠금 방식 덕분에 MyISAM 보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.
- InnoDB 스토리지 엔진에는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재한다.

![Untitled](Chapter%2005%2059be240bb62448fd910dc95d0acc3907/Untitled.png)

### 레코드 락(Record Lock)

- 레코드 자체만을 잠그는 것을 말한다.
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
- 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
- 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.
    - 즉, 쿼리의 조건이 한 건을 보장하는 경우는 레코드 락을 건다.
    - 쿼리의 조건이 1건을 보장하지 못하는 경우에는 넥스트 키 락 또는 갭 락을 건다. (레코드가 없거나, 여러 컬럼으로 구성된 복합 인덱스를 일부 컬럼만으로 WHERE 조건이 사용된 경우도 포함한다.)

### 갭 락(Gap Lock)

- 갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것이다.
- 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다.

### 넥스트 키 락(Next Key Lock)

- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다.
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다.
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
- 하지만 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.
    - 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.
- MySQL 8.0 버전부터는 ROW 포맷의 바이너리 로그에 대한 안정성이 높아졌고, SBR 포맷이 가지는 단점을 많이 해결해줄 수 있기 때문에 MySQL 8.0버전에서는 RBR이 기본 설정이 되었다.

### 자동 증가 락(Auto Increment Lock)

- MySQL에서는 자동 증가하는 숫자 값을 채번하기 위해 AUTO_INCREMENT라는 컬럼 속성을 제공한다.
- AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져와야 한다.
- InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.
- AUTO_INCREMENT 락은 INSERT와 REPLACE 쿼리와 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE나 DELETE 등의 쿼리에서는 걸리지 않는다.
- 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.
    - AUTO_INCREMENT 락은 아주 짧은 시간동안 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제가 되지 않는다.
- AUTO_INCREMENT 락은 테이블에 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.
    - AUTO_INCREMENT 컬럼에 명시적으로 값을 설정하더라도 자동 증가 락을 걸게 된다.
- 자동 증가 락은 잠금을 최소화하기 위해 한 번 증가하면 절대 자동으로 줄어들지 않으며, 한 번 채번에 성공했지만 트랜잭션이 롤백되는 경우에도 복구되지 않고 그대로 남는다.
- 자동 증가 락의 값을 초기화하려면 아래의 쿼리를 사용해야 한다.

```jsx
ALTER TABLE table_name AUTO_INCREMENT = 1
```

### 인덱스와 잠금

- InnoDB의 잠금은 레코드가 아닌 인덱스를 잠그는 방식으로 처리되는데, 적절한 인덱스가 준비돼 있지 않다면 동시성이 상당히 떨어질 수 있다.
- 만약 인덱스가 하나도 없다면 테이블을 풀 스캔하면서 UPDATE 작업을 한다. 따라서 인덱스 설계가 매우 중요하다.

### READ UNCOMMITTED

- 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 관찰 가능하다.

![Untitled](Chapter%2005%2059be240bb62448fd910dc95d0acc3907/Untitled%201.png)

- 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 관찰할 수 있는 현상을 Dirty Read라고 한다.
- READ UNCOMMITTED 격리 수준에서는 Dirty Read가 허용된다.
- 정합성에 많은 문제를 일으키므로 사용하지 않는 것이 좋다.

### READ COMMITTED

- 오라클 DBMS에서 기본으로 사용되는 격리 수준이며, Dirty Read 현상은 발생하지 않는다.
    - 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 관찰이 가능하기 때문이다.

![Untitled](Chapter%2005%2059be240bb62448fd910dc95d0acc3907/Untitled%202.png)

- READ COMMITTED 격리 수준에서는 NON-REPEATABLE READ라는 부정합 문제가 발생한다.

### REPEATABLE READ

- MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.
- RBR을 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다.
- NON-REPEATABLE READ 부정합 문제가 발생하지 않는다.
    - InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 로그로 백업해두고 실제 레코드 값을 변경하기 때문에 백업된 언두로그로 동일 트랜잭션에서 동일한 결과를 보여줄 수 있도록 보장하는 것이다.
- 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)을 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함돼 있다.
- REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다.
    - 트랜잭션은 자신에게 부여된 트랜잭션 번호보다 작은 트랜잭션 번호에서 변경한 것만 보게 된다.

![Untitled](Chapter%2005%2059be240bb62448fd910dc95d0acc3907/Untitled%203.png)

- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 PHANTOM READ 라고 하는데, REPEATABLE READ 격리 수준에서 발생할 수 있다.
- SELECT … FOR UPDATE 쿼리는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. (언두 로그는 append only이기 때문에 잠금을 걸 수 없다.)
    - 그래서 SELECT … FOR UPDATE나 SELECT … LOCK IN SHARE MODE로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오는 것이다.
    - 이로 인해 처음 select는 잠금 없이 읽고, 두 번째 select 에서는 for update로 레코드를 읽는 경우에 팬텀 리드가 발생할 수 있다. (일반적인 케이스는 아니므로 발생할 일이 거의 없긴하다.)

### SERIALIZABLE

- 가장 단순한 격리 수준이면서 가장 엄격한 격리 수준이다. 그만큼 동시 처리 성능도 다른 격리 수준보다 떨어진다.
- InnoDB 테이블에서는 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행된다.
- 하지만 SERIALIZABLE로 설정되면 읽기 작업도 공유 잠금(Shared Lock)을 획득해야 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
- PHANTOM READ 문제는 발생하지 않는다.
    - 하지만 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ 문제가 발생하지 않으므로 SERIALIZABLE을 사용할 필요성은 없다.
