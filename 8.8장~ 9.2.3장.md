# 클러스터링 인덱스 

## 8.8 클러스터링 인덱스 

1. 클러스터링 이란, 여러개를 하나로 묶는 다는 의미 
2. mysql 서버 에서의 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키 기준)들끼리 묶어서 저장하는 형태로 구성 
3. mysql 서버의 클러스터링은 innoDB에서만 지원함.


### 8.8.1 

1. 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용됨
2. 클러스터링 된 테이블은 프라이머리 키 값 자체 에 대한 의존도가 높아 신중히 프라이머리 키값을 결정 해야함.
3. b-tree도 인덱스 키값으로 정렬되어 있지만 클러스터링 인덱스라 하지 않는다. 테이블 레코드 가
프라이머리 키값을 기준으로 정렬된 경우에만 클러스터링 인덱스라 함.

클러스터링 인덱스 = 클러스터링 테이블(테이블 레코드의 저장 방식)

<img width="449" alt="스크린샷 2024-03-10 오전 2 43 17" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/0005c27f-5452-4348-9e31-8c824749069f">

myisam 테이블 이나 다른 스토리지 엔진의 테이블은 인덱스 키 값이 변경된다고 해서 데이터 레코드의 위치는 변경되지 않는다. 
데이터 레코드가 insert 될때 데이터 파일의 끝에 저장한다.

한번 결정된  위치는 절대 빠뀌지 않고 레코드가 저장 된 주소는 Mysql 내부적으로 레코드를 식별하는 아이디로 인식된다. 
이를 ROW_ID 라고표현 하며, mysql 에서는 이값은 노출 되지 않는다.

### 8.8.2 세컨더리 인덱스 에 미치는 영향 

세컨터리 인덱스 -> 메인 테이블의 기본키가 아닌 다른열 에 대한 인덱스

1. Myisam 이나 memory 스토리지 엔진에서는 프라이머리 키 와 세컨더리 인덱스는 구조적으로 차이가 없다.
2. innoDB는 세컨 더리 인덱스 가 실제 저장된 주소를 가지고 있다면 클러스터링 키값이 변경 될때 마다 데이터 레코드의 주소가 바뀌고 해당 테이의 모든 인덱스에 저장된 주솟값을 변경해야 하기때문에 InnoDB 의 클러스터링 테이블 의 모든 세컨더리 인덱스는 해당 레코드의 실제 주소가 아니라 프라이머리 키 값을 저장하도록 한다.

### 8.8.3 클러스터링 인덱스의 장점과 단점 

장점
1. 프라이머리 키 로 검색할때 처리 성능이 매우 빠름
2. 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기에 인덱스 많으로 처리 될수 있는 경우가 많음(커버링 인덱스)

단점
1. 테이블의 모든 세컨더리 이덱스가 클러스터링 키를 갖기 떄문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
2. 세컨더리 인덱스를 통해 검색 할떄 프라이머리 키로 다시한번 검색해야 함으로 처리성능이 느림
3. INSERT 할때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리성능이 느림
4. 프라이머리 키 를 변경할때 레코드를 delete 하고 INSERT하는 작업이 필요하기에 처리성능이 느림

### 8.8.4 클러스터링 테이블 사용시 주의사항 

#### 클러스터링 인덱스 키의 크기 

<img width="597" alt="스크린샷 2024-03-10 오전 3 48 31" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/4e0594ea-00c8-4162-8813-a370dd21f82c">


#### 프라이머리 키는 auto-increment 보다는 업무적인 칼럼으로 생성 
"Auto Increment"는 자동 증가하는 숫자 값으로, 주로 데이터베이스의 테이블에서 사용되는 기능입니다. 주로 테이블의 기본키(primary key)에 사용되며, 데이터베이스가 자동으로 값을 증가시켜주기 때문에 일련번호를 생성하는 데 유용합니다.

클러스터링 인덱스를 지원하지 않는 스토리지엔진에서는 키값으로 뭘 선택 해도 성능 차이는 크게 나지 않는다 .
하지만 프라이머리 키는 데이블을 대표하는 키 값 이니만큼 검색에 많이 사용된다. 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표 할수 있다면 해당 칼럼을 프라이머리 키로 사용할것.


#### 프라이 머리 키는 반드시 명시 할것 

innoDB에서는 프라이머리 키가 없는 테이블에 관해서는 스토리지 엔진이 자동으로 일련번호를 부여 하게 되는데 이는 사용자가 접근할수 없다. 왠만하면 auto-increment 를 사용해서 라도 프라이머리 키를 생성할것,

#### auto-increment 칼럼을 인조 식별자로 사용할 경우 
여러 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 크더라도 세컨더리 인덱스가 필요치 않는다면 그대로 프라이머리 키로 사용하는 것이 좋다.

세컨더리 인덱스가 필요하다면 auto-increment 사용해서 칼럼을 추가하고 키로 설정한다. 
이를 인조 식별자라 한다. 


## 8.9 유니크 인덱스 

1. 이는 인덱스 라기 보다 제약조건에 가까움 
2. 테이블이나 인덱스 같은 값은 2개 이상 저장 될수 없음을 의미
3. mysql 에서는 인덱스 없이 유니크 제약만 설정할수 없음


#### 유니크 인덱스 vs 일반 세컨더리 인덱스 

유니크 인덱스 와 일반 세컨더리 인덱스는 구조상으로 아무런 차이점이 없다.



#### 읽기

유니크 인덱스(Unique Index):
읽기 작업에서는 유니크 인덱스와 일반 세컨더리 인덱스의 차이가 거의 없다. 둘 다 검색 연산을 통해 특정 값을 빠르게 찾을 수 있다.
유니크 인덱스는 중복을 허용하지 않기 때문에 해당 값이 존재하는지 확인하는 작업에서 유용함.
따라서 중복 검사가 필요한 경우에 유용 

일반 세컨더리 인덱스(Non-Unique Secondary Index):
일반 세컨더리 인덱스도 특정 값을 빠르게 찾을 수 있으며, 중복된 값도 허용, 따라서 해당 값이 여러 개 존재할 수 있는 경우에 사용 된다.
세컨더리 인덱스는 유니크 인덱스와 마찬가지로 특정 조건에 맞는 레코드를 검색하는 데 사용된다.

#### 쓰기 

유니크 인덱스(Unique Index):

쓰기 작업에서는 유니크 인덱스를 가진 테이블에 새로운 값이나 업데이트가 발생할 때 중복 검사가 추가로 수행된다.
따라서 쓰기 작업이 더 많은 오버헤드를 가질 수 있음.
새로운 레코드의 삽입이나 기존 레코드의 업데이트가 유니크 인덱스의 제약 조건을 위반하면 오류가 발생한다.

일반 세컨더리 인덱스(Non-Unique Secondary Index):
일반 세컨더리 인덱스는 중복을 허용하기 때문에 쓰기 작업에서는 추가적인 중복 검사가 필요하지 않음,
따라서 쓰기 작업의 오버헤드가 적다.
세컨더리 인덱스를 가진 테이블에 대해 더 자주 쓰기 작업이 발생하는 경우 유용


## 8.10 외래키 

mysql 에서 왜래키는 innoDB 스토리 엔진에서만 생성가능 , 외래 키 제약 이 설정되면 자동으로 연관 되는 테이블 의 칼럼에 인덱스 까지 생성된다. 

특징 
1. 테이블의 변경 이 발생하는 경우에만 잠금 대기가 발생
2. 왜래키과 연관 되지 않은 칼럼의 변경은 최대힌 잠금 대기를 발생 시키지 않는다.


### 8.10.1 자식 테이블의 변경이 대기 하는 경우 

<img width="589" alt="스크린샷 2024-03-10 오전 4 10 32" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/61271f4d-c4d0-4a18-b80e-d3de768fe69c">

1. 트랜잭션에서 부모 테이블의 레코드에 대해 쓰기 잠금을 획득한 후 UPDATE를 실행한다.

2. 다른 커넥션에서 해당 부모 테이블의 레코드를 참조하는 자식 테이블의 외래키 값을 변경하는 쿼리를 실행하면, 해당 작업은 부모 테이블의 변경이 완료될 때까지 대기한다.

3. 트랜잭션을 ROLLBACK이나 COMMIT으로 종료하면, 대기 중인 자식 테이블의 쿼리가 즉시 처리된다.

4. 자식 테이블의 외래키(pid)가 아닌 다른 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.


즉 자식 테이블의 외래 키 칼럼의 변 경(INSERT, UPDATE)은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 되는 것이다. 이것이 InnoDB의 외래키 관리의 첫 번째 특징에 해당한다.

### 8.10.2 부모 테이블의 변경 작업이 대기 하는 경우 


<img width="598" alt="스크린샷 2024-03-10 오전 4 12 29" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/bb9ec649-15dd-4837-b21c-07404ceff182">

1. 첫 번째 커넥션에서 자식 테이블의 레코드를 변경하면 해당 레코드에 대해 쓰기 잠금을 획득한다.

2. 두 번째 커넥션에서 부모 테이블에서 특정 레코드를 삭제하면, 해당 레코드를 참조하는 자식 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 대기해야 한다.

3. 이는 자식 테이블에 정의된 외래키의 특성(ON DELETE CASCADE)으로 인해 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 동작 때문이다.

4. 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가될 때 해당 참조키가 부모 테이블에 있는지 확인하기 위해 연관 테이블에 읽기 잠금을 걸어야 한다. 이는 쿼리의 동시 처리에 영향을 줄 수 있다.

## 9.1 옵티마이저와 힌트 

어떤 DBMS든지 쿼리의 실행 계획을 수립 하는 옵티 마이저 는 가장 복잡한 부분이다. 
실행 계획 을 이해 할수 있어야만 불합리 한 부분을 찾아내고 최적화 할수 있다. 


### 9.1.1 쿼리 실행 절차 

쿼리 실행 과정 

1. 사용자로 부터 요청된 sql 문장을 잘게 쪼개서 Mysql 서버가 이해할 수 있는 수준으로 분리(파스 트리) 한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

부가 설명 
1번 -> SQL파싱 이라 칭하고 SQL 파서 가 해당 작업을 처리 , SQL 파스트리를 생성 

2번 -> 불필요한 조건 제거 및 복잡한 연산의 단순화, 

여러테이블 의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정 , 

각 테이블에서 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정, 

가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정 

이는 최적화 및 실행 계획 수립 단계 를 뜻 하며 SQL 의 옵티마이저 에서 처리,


### 9.1.2 옵티마이저의 종류 

1. 현재 대부분의 DBMS 가 선택하고 있는 비용 기반 최적화CBO(Cost Based Optimizer)
2. 오라클 DBMS에서 사용되었는 규칙 기반 최적화 RBO(Rule Based Optimizer)


#### 규칙 기반 최적화 

1. 대상 테이블의 레코드 건수나 선택도 등을 고려 하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립함.
2. 통계 정보를 조사하지 않기에 , 같은 쿼리에 대해 항상 같은 실행 방법을 만들어 냄
3. 사용자의 데이터 분포가 다양해 짐에 따라 현재는 사용되지않음


#### 비용 기반 최적화 

1. 쿼리를 최적화 하기 위한 여러가지 가능한 방법을 만듬
2. 각 단위 작업의 비용(부하) 정보와 대상 테이블 의 예측된 통계 정보를 이용 실행계획뵬 비용을 산출
3. 위의 데이터를 기반으로 비용이 최소가 되는 방법을 실행


## 9.2 기본 데이터 처리 

Mysql 서버를 포함한 모든 DBMS 는 데이터 정렬,그루핑 등 기본 데이터 가공 기능 을 포함한다.

### 9.2.1  풀 데이터 스캔과 풀 인덱스 스캔 

1. 풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 작업을 처리하는 것이다.
2. 풀 테이블 스캔은 주로 테이블의 레코드 건수가 매우 작거나 인덱스를 이용할 수 없는 경우에 선택된다.
3. InnoDB 스토리지 엔진에서는 풀 테이블 스캔 시 리드 어헤드(Read ahead) 기능을 사용하여 백그라운드 스레드를 통해 데이터를 미리 읽어와 버퍼 풀에 저장하여 성능을 향상시킨다.
4. 풀 인덱스 스캔은 인덱스를 처음부터 끝까지 읽어서 작업을 처리하는 것이다.
5. 풀 인덱스 스캔은 테이블의 레코드 건수가 매우 작고 작업이 인덱스만으로 충분히 처리될 때 선택된다.


### 9.2.2 병렬 처리 

병렬 처리란 하나의 쿼리를 여러 스레드가 나누어 동시에 처리 한다는 것을 의미 

mysql 8.0 부터 innodb_parallel_read_thread 라는 시스탬 변수를 통해 하나의 쿼리를 최대 몇개의 스레드를 이용해서 처리할지 지정 가능 

아직까지는 해당 기능이 존재하지 않았다. 

```

mysql> SET SESSION innodb_parallel_read_threads=1; mysql> SELECT COUNT(*) FROM salaries;
1 ron in set (0.32 sec)

mysql> SET SESSION innodb_parallel_read_threads=2; mysql> SELECT COUNT(*) FROM salaries;
1 ron in set (0.20 sec)

mysql> SET SESSION innodb_parallel_read_threads=4; mysql> SELECT COUNT(*) FROM salaries;
1 ron in set (0.18 sec)

mysql > SET SESSION innodb_parallel_read_threads=8; mysql> SELECT COUNT(*) FROM salaries;
1 ron in set (0.13 sec)

```

### 9.2.3 ORDER BY 처리(using filesort)





