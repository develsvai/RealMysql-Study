 ### 쿼리 에서 인덱스 를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 되는지 에대한 두가지 처리 방법에 대한 견해
##### 9.2.3.3.4.1 스트리밍 방식 

1. 스트리밍 방식은 서버에서 데이터 처리와 동시에 클라이언트로 결과를 전송한다.
2. 클라이언트는 첫 번째 레코드를 받자마자 데이터 처리를 시작할 수 있다.
3. 쿼리의 응답 시간을 빠르게 하며, LIMIT과 같은 조건은 전체 실행 시간을 줄여준다.
4. 스트리밍 방식은 쿼리가 얼마나 많은 레코드를 조회 하느냐 와 상관없이 빠른 응답 시간을 보장한다.


#### 9.2.3.3.4.2 버퍼링 방식 


1. ORDER BY나 GROUP BY와 같은 처리는 스트리밍 방식을 불가능하게 함.
2. 버퍼링 방식에서는 모든 결과를 일괄적으로 가져와서 가공해야 하므로 클라이언트는 결과를 기다려야 함.
3. 버퍼링 방식은 LIMIT과 같은 제한 조건이 성능 향상에 크게 도움되지 않음.

#### 9.2.3.4 정렬 관련 상태 변수 

<img width="413" alt="스크린샷 2024-03-16 오전 3 52 10" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/3dc1337e-b4af-4975-8e05-bd79066cdf64">


### 9.2.4 GROUP BY 처리 

1. GROUP BY와 ORDER BY는 스트리밍 처리를 불가능하게 함.
2. HAVING 절은 GROUP BY 결과를 필터링하는 역할을 함.
3. GROUP BY 작업은 인덱스를 사용할 수 있는 경우와 사용할 수 없는 경우로 나뉘며, 사용할 수 없는 경우에는 임시 테이블을 사용함.

#### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
1. 조인의 드라이빙 테이블에 속한 칼럼으로 그루핑할 때 GROUP BY 칼럼에 이미 인덱스가 있다면, 해당 인덱스를 사용하여 그루핑 작업을 수행하고 조인을 처리함.
2. GROUP BY가 인덱스를 사용할 때도 그룹 함수 등의 처리로 인해 임시 테이블이 필요할 수 있음.
3. 정렬된 인덱스를 읽는 경우에는 쿼리 실행 시 추가적인 정렬 작업이나 내부 임시 테이블이 필요하지 않음.
4. 이러한 그루핑 방식을 사용하는 쿼리의 실행 계획에서는 특별한 코멘트가 Extra 칼럼에 표시되지 않음.

### 루스 인덱스 스캔을 이용하는 GROUP BY

1. 루스 인덱스 스캔은 GROUP BY 작업에 사용될 때, 인덱스를 건너뛰면서 읽음.
2. GROUP BY에서 이미 인덱스가 있는 경우에도, 그룹 함수 등의 처리로 인해 임시 테이블이 필요할 수 있음.
3. 루스 인덱스 스캔을 사용하는 경우에는 인덱스를 건너뛰며 읽기 때문에 추가적인 정렬 작업이나 내부 임시 테이블이 필요할 수 있음.
4. 실행 계획에서는 정렬 관련 코멘트가 표시되거나, 임시 테이블 사용에 대한 정보가 나타날 수 있음.
5. 루스 인덱스 스캔을 사용하는 GROUP BY 쿼리는 성능 면에서 제약이 있을 수 있으며, 튜닝이 필요할 수 있음.


### 임시 테이블을 사용하는 GROUP BY

1. 임시 테이블을 사용하는 GROUP BY는 그룹 함수나 정렬을 위해 임시적으로 데이터를 저장하는 과정이 필요함.
2. GROUP BY 작업 중에는 결과를 저장하기 위한 임시 테이블이 생성되며, 이를 통해 그룹핑이 이루어짐.
3. 임시 테이블 사용은 추가적인 디스크 공간과 CPU 리소스를 필요로 하며, 성능 저하의 요인이 될 수 있음.
4. 실행 계획에서는 "Using temporary"라는 코멘트가 나타나며, 성능 튜닝에 필요한 정보를 제공함.
5. 임시 테이블을 사용하는 GROUP BY 쿼리는 성능 최적화를 위해 쿼리 및 인덱스를 재조정할 필요가 있음.


### 9.2.5 DISTINCT 처리 

1. SELECT DISTINCT를 사용하여 유니크한 레코드를 가져올 수 있음.
2. DISTINCT는 SELECT되는 레코드 전체를 유니크하게 선택하는 것이며, 특정 칼럼만을 유니크하게 조회하는 것은 아님.
3. DISTINCT 뒤의 괄호는 함수가 아니므로 의미가 없으며, MySQL 서버는 이를 무시함.
4. DISTINCT 키워드는 SELECT하는 모든 칼럼에 영향을 미침. 특정 칼럼만 유니크하게 조회하는 것은 아님.
5. DISTINCT와 함께 집합 함수를 사용하는 경우는 다른 동작을 함.


#### 집합 함수와 함께 사용된 DISTINCT 

1. DISTINCT와 함께 집합 함수를 사용하는 경우, 해당 함수가 적용된 결과를 유니크하게 가져옴.
2. 집합 함수와 함께 사용된 DISTINCT는 해당 함수의 결과를 유니크하게 만듦.
3. 예를 들어, COUNT(), SUM(), AVG()와 같은 집합 함수와 함께 사용될 때 유용함.
4. 이러한 경우, DISTINCT는 집합 함수의 결과 집합을 중복 없이 만들어줌.
5. DISTINCT와 집합 함수를 함께 사용할 때, 함수가 적용된 결과를 중복 없이 반환함.

### 9.2.6 내부 임시 테이블 활용 

1. MySQL 엔진은 정렬이나 그루핑을 위해 내부적인 임시 테이블을 사용함.
2. 이 내부적인 임시 테이블은 CREATE TEMPORARY TABLE로 만든 임시 테이블과는 구별되며, 다른 세션이나 쿼리에서는 볼 수 없고 사용할 수 없음.
3. 일반적으로 임시 테이블은 메모리에 생성되고, 크기가 커지면 디스크로 옮겨짐.
4. MySQL 엔진이 사용하는 내부적인 임시 테이블은 쿼리 처리가 완료되면 자동으로 삭제됨.

#### 메모리 임시 테이블과 디스크 임시 테이블 

1. MySQL 8.0 이전 버전에서는 MEMORY 스토리지 엔진 또는 MyISAM 스토리지 엔진을 사용하여 임시 테이블을 생성함.
2. MySQL 8.0 버전부터는 TempTable 스토리지 엔진 또는 InnoDB 스토리지 엔진을 사용하여 임시 테이블을 생성함.
3. MEMORY 스토리지 엔진은 가변 길이 타입을 지원하지 않아 메모리 낭비가 발생할 수 있었으며, MyISAM은 트랜잭션을 지원하지 않는 문제가 있었음.
4. MySQL 8.0에서는 가변 길이 타입을 지원하는 TempTable 스토리지 엔진과 트랜잭션을 지원하는 InnoDB 스토리지 엔진을 사용하여 임시 테이블을 생성함.
5. 내부 임시 테이블은 다른 세션이나 쿼리에서는 볼 수 없고 사용할 수 없으며, 쿼리 처리가 완료되면 자동으로 삭제됨.

#### 임시 테이블이 필요한 쿼리 

1. ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리는 내부 임시 테이블을 생성하는 대표적인 케이스.
2. DISTINCT와 ORDER BY가 동시에 쿼리에 존재하거나 DISTINCT가 인덱스로 처리되지 못하는 쿼리도 내부 임시 테이블을 필요로 함.
3. UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT인 경우)도 내부 임시 테이블을 사용함.
4. 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리도 내부 임시 테이블을 사용할 수 있음.
5. 실행 계획에서 "Using temporary"라는 메시지가 표시되지 않아도 내부 임시 테이블이 사용될 수 있음.

#### 임시 테이블이 디스크에 생성 되는 경우 

1. 임시 테이블이 메모리에 생성되더라도 크기가 1GB를 넘으면 디스크에 저장될 수 있음.
2. 임시 테이블이 디스크에 저장될 때는 TempTable 스토리지 엔진 또는 InnoDB 스토리지 엔진을 사용함.
3. MySQL 8.0부터는 임시 테이블이 디스크에 저장될 때 InnoDB 스토리지 엔진이 사용되며, 이전 버전에서는 MyISAM 스토리지 엔진이 사용되었음.
4. 임시 테이블이 디스크에 저장될 때 파일은 "tmpdir" 시스템 변수에 정의된 디렉터리에 저장됨.
5. 임시 테이블이 디스크에 저장되면 MySQL 서버는 즉시 파일을 삭제하여 보안과 성능을 유지함.

#### 임시테이블 관련 상태 변수 

• Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값이다. 이 값은 내 부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적한다.

• Created_tmp_disk_tables: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값이다.


## 9.3 고급 최적화 
옵티마이저 옵션은 통계 정보와 함께 조인 관련된 옵션과 옵티마이저 스위치로 구분되며, 최적의 실행 계획을 결정하는 데 사용됨.


### 9.3.1 옵치 마이저 스위치 옵션 

<img width="586" alt="스크린샷 2024-03-16 오전 4 23 20" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/82584240-727a-4b0f-8eae-3f6f3aa1c767">

<img width="594" alt="스크린샷 2024-03-16 오전 4 24 15" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/d8092a1d-f875-4369-84af-487d38d6a0c4">


각각의 옵티마이저 스위치 옵션은 "defaul"와 "on", "off" 중에서 하나를 설정할 수 있는데, "on"으로 설정되면 해당 옵션을 활성화하고, "ofr를 설정하면 해당 옵션을 비활성화한다. 그리고 "defaut"를 설 정하면 기본값이 적용된다. 옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변 수이므로 MysOL 서버 전체적으로 또는 현재 커넥션에 대해서만 다음과 같이 설정할 수 있다.

#### MPR과 배치 키 액세스(mrr & batched_key_access)

1. MRR(Multi-Range Read)은 조인 대상 테이블 중 하나로부터 레코드를 읽어 조인 버퍼에 버퍼링하여 데이터 페이지에 정렬된 순서로 접근하는 MySQL의 조인 최적화 기법이다.
2. 이를 응용한 BKA(Batched Key Access) 조인은 조인 처리를 최적화하여 디스크의 데이터 페이지 읽기를 최소화한다.
3. BKA 조인은 기본적으로 비활성화되어 있으며, 쿼리의 특성에 따라 사용 여부를 결정해야 한다.


#### 블록 네스티드 루프 조인(block_nested_loop)

1. 블록 네스티드 루프 조인(Block Nested Loop Join)은 MySQL 8.0에서 도입된 새로운 조인 알고리즘 중 하나이다.
2. 이 알고리즘은 드라이빙 테이블에서 일정 범위의 블록(데이터 블록)을 읽어 드리븐 테이블과 조인을 수행하는 방식으로 동작한다.
3. 블록 네스티드 루프 조인은 MRR(Multi-Range Read)과 함께 사용되며, 드라이빙 테이블의 레코드를 읽어오는 방식에서 최적화를 실시한다.
4. 이 알고리즘은 대용량 테이블 간의 조인에서 성능 향상을 가져올 수 있으며, 디스크 I/O를 줄여 최적화된 조인 처리를 가능하게 한다.
5. 블록 네스티드 루프 조인은 쿼리 옵티마이저에 의해 자동으로 선택되며, 사용자가 직접 설정할 수는 없다.

<img width="603" alt="스크린샷 2024-03-16 오전 4 30 54" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/88151d93-f658-4b5f-824e-5e4f9469cd37">


#### 인덱스 컨디션 푸시다운(index_condition_pushdown)

1. 인덱스 컨디션 푸시다운(Index Condition Pushdown)은 MySQL 8.0에서 도입된 최적화 기법 중 하나이다.
2. 이 기법은 WHERE 절의 조건을 인덱스를 사용하여 더 효율적으로 처리함으로써 쿼리의 성능을 향상시킨다.
3. MySQL 8.0에서는 인덱스를 사용해 WHERE 절의 조건을 필터링한 후에 나머지 조건을 테이블 스캔 시에 적용하는 방식으로 동작한다.
4. 이를 통해 데이터베이스가 불필요한 테이블 레코드를 스캔하는 것을 방지하고, 인덱스를 더 효율적으로 활용하여 쿼리의 실행 속도를 향상시킨다.
5. 인덱스 컨디션 푸시다운은 쿼리 옵티마이저에 의해 자동으로 적용되며, 사용자가 별도로 설정할 필요가 없다.


#### 인덱스 확장(use_index_extentions)

1. 인덱스 확장(Use Index Extensions)은 MySQL 8.0에서 도입된 옵티마이저 옵션으로, 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용하여 쿼리를 최적화한다.
2. 이 기능을 통해 세컨더리 인덱스를 사용할 때 프라이머리 키를 활용함으로써 성능을 향상시킬 수 있다.
3. 세컨더리 인덱스는 프라이머리 키 값을 함께 가지고 있기 때문에, 세컨더리 인덱스만을 이용하여 쿼리를 처리할 때도 프라이머리 키의 정보를 활용할 수 있다.
4. 이를 통해 정렬 작업이나 레코드 접근 시 프라이머리 키의 순서를 활용할 수 있어 성능 향상을 기대할 수 있다.
5. 인덱스 확장은 옵티마이저에 의해 자동으로 활성화되며, 쿼리 실행 계획에서 "Using index"와 같은 형태로 표시된다.
6. 이를 통해 세컨더리 인덱스를 보다 효율적으로 활용하여 쿼리 성능을 최적화할 수 있다.


#### 인덱스 머지(inex_merge)


1. 인덱스 머지 실행 계획은 하나의 테이블에 대해 2개 이상의 인덱스를 사용하여 쿼리를 처리하는 방식이다.
2. 쿼리에서 한 테이블에 대한 WHERE 조건이 여러 개 있을 때, 각각의 조건에 해당하는 인덱스를 사용하여 검색한 후, 결과를 병합하는 방식이다.
3. 인덱스 머지 실행 계획은 다음과 같이 3가지 세부 실행 계획으로 나뉜다: index_merge_intersection, index_merge_sort_union, index_merge_union.
4 .index_merge 옵티마이저 옵션은 이 3가지 최적화 옵션을 한 번에 모두 제어할 수 있다.
5. 각각의 최적화 알고리즘은 쿼리의 특성에 따라 선택되며, 각각의 동작 방식에 대해 적합한 예제 쿼리를 통해 살펴볼 수 있다.


#### 인덱스 머지 - 교집합(index_merge_intersection)

1. 인덱스 머지 실행 계획은 하나의 테이블에 대해 2개 이상의 인덱스를 사용하여 쿼리를 처리하는 방식이다.
2. 각각의 조건에 대해 인덱스를 사용하여 결과를 검색한 후, 두 결과의 교집합만 반환하는 방식으로 동작한다.
3. 이 방식은 각 조건에 대해 예상되는 레코드 건수가 많고, 각각의 인덱스를 사용하여 처리할 때 비효율적인 경우에 선택된다.
4. 쿼리의 예상 레코드 건수를 고려하여 옵티마이저는 가장 효율적인 실행 계획을 선택하게 된다.
5. index_merge_intersection 최적화를 비활성화하면 각각의 조건에 대해 인덱스를 따로 사용하는 실행 계획이 선택될 수 있다.





