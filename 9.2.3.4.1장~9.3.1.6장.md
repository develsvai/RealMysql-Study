 ### 쿼리 에서 인덱스 를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 되는지 에대한 두가지 처리 방법에 대한 견해
##### 9.2.3.3.4.1 스트리밍 방식 

1. 스트리밍 방식은 서버에서 데이터 처리와 동시에 클라이언트로 결과를 전송한다.
2. 클라이언트는 첫 번째 레코드를 받자마자 데이터 처리를 시작할 수 있다.
3. 쿼리의 응답 시간을 빠르게 하며, LIMIT과 같은 조건은 전체 실행 시간을 줄여준다.
4. 스트리밍 방식은 쿼리가 얼마나 많은 레코드를 조회 하느냐 와 상관없이 빠른 응답 시간을 보장한다.


#### 9.2.3.3.4.2 버퍼링 방식 


1. ORDER BY나 GROUP BY와 같은 처리는 스트리밍 방식을 불가능하게 함.
2. 버퍼링 방식에서는 모든 결과를 일괄적으로 가져와서 가공해야 하므로 클라이언트는 결과를 기다려야 함.
3. 버퍼링 방식은 LIMIT과 같은 제한 조건이 성능 향상에 크게 도움되지 않음.

#### 9.2.3.4 정렬 관련 상태 변수 

<img width="413" alt="스크린샷 2024-03-16 오전 3 52 10" src="https://github.com/develsvai/RealMysql-Study/assets/125961256/3dc1337e-b4af-4975-8e05-bd79066cdf64">


### 9.2.4 GROUP BY 처리 

1. GROUP BY와 ORDER BY는 스트리밍 처리를 불가능하게 함.
2. HAVING 절은 GROUP BY 결과를 필터링하는 역할을 함.
3. GROUP BY 작업은 인덱스를 사용할 수 있는 경우와 사용할 수 없는 경우로 나뉘며, 사용할 수 없는 경우에는 임시 테이블을 사용함.

#### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
1. 조인의 드라이빙 테이블에 속한 칼럼으로 그루핑할 때 GROUP BY 칼럼에 이미 인덱스가 있다면, 해당 인덱스를 사용하여 그루핑 작업을 수행하고 조인을 처리함.
2. GROUP BY가 인덱스를 사용할 때도 그룹 함수 등의 처리로 인해 임시 테이블이 필요할 수 있음.
3. 정렬된 인덱스를 읽는 경우에는 쿼리 실행 시 추가적인 정렬 작업이나 내부 임시 테이블이 필요하지 않음.
4. 이러한 그루핑 방식을 사용하는 쿼리의 실행 계획에서는 특별한 코멘트가 Extra 칼럼에 표시되지 않음.

### 루스 인덱스 스캔을 이용하는 GROUP BY

1. 루스 인덱스 스캔은 GROUP BY 작업에 사용될 때, 인덱스를 건너뛰면서 읽음.
2. GROUP BY에서 이미 인덱스가 있는 경우에도, 그룹 함수 등의 처리로 인해 임시 테이블이 필요할 수 있음.
3. 루스 인덱스 스캔을 사용하는 경우에는 인덱스를 건너뛰며 읽기 때문에 추가적인 정렬 작업이나 내부 임시 테이블이 필요할 수 있음.
4. 실행 계획에서는 정렬 관련 코멘트가 표시되거나, 임시 테이블 사용에 대한 정보가 나타날 수 있음.
5. 루스 인덱스 스캔을 사용하는 GROUP BY 쿼리는 성능 면에서 제약이 있을 수 있으며, 튜닝이 필요할 수 있음.


### 임시 테이블을 사용하는 GROUP BY

1. 임시 테이블을 사용하는 GROUP BY는 그룹 함수나 정렬을 위해 임시적으로 데이터를 저장하는 과정이 필요함.
2. GROUP BY 작업 중에는 결과를 저장하기 위한 임시 테이블이 생성되며, 이를 통해 그룹핑이 이루어짐.
3. 임시 테이블 사용은 추가적인 디스크 공간과 CPU 리소스를 필요로 하며, 성능 저하의 요인이 될 수 있음.
4. 실행 계획에서는 "Using temporary"라는 코멘트가 나타나며, 성능 튜닝에 필요한 정보를 제공함.
5. 임시 테이블을 사용하는 GROUP BY 쿼리는 성능 최적화를 위해 쿼리 및 인덱스를 재조정할 필요가 있음.


### 9.2.5 DISTINCT 처리 

1. SELECT DISTINCT를 사용하여 유니크한 레코드를 가져올 수 있음.
2. DISTINCT는 SELECT되는 레코드 전체를 유니크하게 선택하는 것이며, 특정 칼럼만을 유니크하게 조회하는 것은 아님.
3. DISTINCT 뒤의 괄호는 함수가 아니므로 의미가 없으며, MySQL 서버는 이를 무시함.
4. DISTINCT 키워드는 SELECT하는 모든 칼럼에 영향을 미침. 특정 칼럼만 유니크하게 조회하는 것은 아님.
5. DISTINCT와 함께 집합 함수를 사용하는 경우는 다른 동작을 함.


#### 집합 함수와 함께 사용된 DISTINCT 

1. DISTINCT와 함께 집합 함수를 사용하는 경우, 해당 함수가 적용된 결과를 유니크하게 가져옴.
2. 집합 함수와 함께 사용된 DISTINCT는 해당 함수의 결과를 유니크하게 만듦.
3. 예를 들어, COUNT(), SUM(), AVG()와 같은 집합 함수와 함께 사용될 때 유용함.
4. 이러한 경우, DISTINCT는 집합 함수의 결과 집합을 중복 없이 만들어줌.
5. DISTINCT와 집합 함수를 함께 사용할 때, 함수가 적용된 결과를 중복 없이 반환함.

### 9.2.6 내부 임시 테이블 활용 

1. MySQL 엔진은 정렬이나 그루핑을 위해 내부적인 임시 테이블을 사용함.
2. 이 내부적인 임시 테이블은 CREATE TEMPORARY TABLE로 만든 임시 테이블과는 구별되며, 다른 세션이나 쿼리에서는 볼 수 없고 사용할 수 없음.
3. 일반적으로 임시 테이블은 메모리에 생성되고, 크기가 커지면 디스크로 옮겨짐.
4. MySQL 엔진이 사용하는 내부적인 임시 테이블은 쿼리 처리가 완료되면 자동으로 삭제됨.

#### 메모리 임시 테이블과 디스크 임시 테이블 

1. MySQL 8.0 이전 버전에서는 MEMORY 스토리지 엔진 또는 MyISAM 스토리지 엔진을 사용하여 임시 테이블을 생성함.
2. MySQL 8.0 버전부터는 TempTable 스토리지 엔진 또는 InnoDB 스토리지 엔진을 사용하여 임시 테이블을 생성함.
3. MEMORY 스토리지 엔진은 가변 길이 타입을 지원하지 않아 메모리 낭비가 발생할 수 있었으며, MyISAM은 트랜잭션을 지원하지 않는 문제가 있었음.
4. MySQL 8.0에서는 가변 길이 타입을 지원하는 TempTable 스토리지 엔진과 트랜잭션을 지원하는 InnoDB 스토리지 엔진을 사용하여 임시 테이블을 생성함.
5. 내부 임시 테이블은 다른 세션이나 쿼리에서는 볼 수 없고 사용할 수 없으며, 쿼리 처리가 완료되면 자동으로 삭제됨.

#### 임시 테이블이 필요한 쿼리 

1. ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리는 내부 임시 테이블을 생성하는 대표적인 케이스.
2. DISTINCT와 ORDER BY가 동시에 쿼리에 존재하거나 DISTINCT가 인덱스로 처리되지 못하는 쿼리도 내부 임시 테이블을 필요로 함.
3. UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT인 경우)도 내부 임시 테이블을 사용함.
4. 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리도 내부 임시 테이블을 사용할 수 있음.
5. 실행 계획에서 "Using temporary"라는 메시지가 표시되지 않아도 내부 임시 테이블이 사용될 수 있음.

#### 임시 테이블이 디스크에 생성 되는 경우 

1. 임시 테이블이 메모리에 생성되더라도 크기가 1GB를 넘으면 디스크에 저장될 수 있음.
2. 임시 테이블이 디스크에 저장될 때는 TempTable 스토리지 엔진 또는 InnoDB 스토리지 엔진을 사용함.
3. MySQL 8.0부터는 임시 테이블이 디스크에 저장될 때 InnoDB 스토리지 엔진이 사용되며, 이전 버전에서는 MyISAM 스토리지 엔진이 사용되었음.
4. 임시 테이블이 디스크에 저장될 때 파일은 "tmpdir" 시스템 변수에 정의된 디렉터리에 저장됨.
5. 임시 테이블이 디스크에 저장되면 MySQL 서버는 즉시 파일을 삭제하여 보안과 성능을 유지함.

#### 임시테이블 관련 상태 변수 

• Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값이다. 이 값은 내 부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적한다.

• Created_tmp_disk_tables: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값이다.


## 9.3 고급 최적화 



